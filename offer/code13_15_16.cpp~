/*
 * =====================================================================================
 *
 *       Filename:  code13.cpp
 *    Description:  链表相关 
 *        Created:  2015年05月09日 18时20分54秒
 *         Author:  hudmok (HangDian), hdumok@qq.com
 *
 * =====================================================================================
 */

struct ListNode{
	int value;
	ListNode* next;
}
/*O(1)删除节点 */
void DeleteNode(ListNode** plist,ListNode* pdelete)
{
	if(!plist||!pdelete) //如果传入的指向头指针的指针不存在 或 指向要被删除节点的指针不存在
		return;
	if(p->next!=NULL)//要被删的节点后还有节点
	{
		ListNode* s=p->next;

		p->value=s->value;//完全拷贝下一个节点的数据和指针
		p->next=s->next;

		delete s;
		s=NULL;
	}
	else if(*plist=pdelete)//如果后面没有节点了，而这个又是头节点又是尾节点
	{
		delete pdelete;
		pdelete=NULL;
		*plist=NULL;
	}
	else//如果后面没有节点了，而这又不是唯一节点
	{
		ListNode* p=*plist;
		while(p->next!=pdelete)
			p=p->next;
		p->next=pdelete->next;
		delete pdelete;
		pdelete=NULL;
	}
}	
/*找出链表中倒数第K个节点 */
ListNode* FindTailK(ListNode* phead,unsigned int k)
{
	if(phead==NULL||k==0)
		return NULL;
	ListNode* pAhead=phead;
	ListNode* pBebind=phead;
	for(int i=1;i<k;i++)//执行了K-1次  从指向节点1变成指向节点K
	{
		if(pAhead!=NULL)
			pAhead=pAhead->next;
		else
			return NULL;
	}
	while(pAhead->next)
	{
		pAhead=pAhead->next;
		pBebind=pBebind->next;
	}
	return pBebind;
}
/* 反转链表 */
void ReverseList(ListNode* phead)//假设头节点存在
{
	ListNode* pthis,*pafter,*temp;
	pthis=phead->next;
	if(pthis==NULL)
		return;
	pafter=pthis->next;
	temp=pthis;
	while(pafter)
	{
		pthis=pafter;
		pafter=pafter->next;
		pthis->next=temp;
		temp=pthis;
	}
	phead->next->next=NULL;
	phead->next=pthis;
}
void ReverseList(ListNode** phead)//假设头节点不存在
{
	ListNode *pthis,*pafter,*temp;
	pthis=*phead;
	if(phead==NULL&&*phead)
		return;
	temp=pthis;
	pafter=pthis->next;
	while(pafter)
	{
		pthis=pafter;
		pafter=pafter->next;
		pthis->next=temp;
		temp=pthis;
	}
	(*phead)->next=NULL;
	*phead=pthis;
}
/*合并两个排好序的链表 */
ListNode* MergeList(ListNode* phead1,ListNode* phead2)
{
	if(phead1==NULL)
		return phead2;
	else if(phead2=NULL)
		return phead1;

	ListNode* pmerge=NULL;
	
	if(phead1->value<phead2->value)
	{
		pmerge=phead1;
		pmerge->next=MergeList(phead1->next,phead2);
	}
	else
	{
		pmerge=phead2;
		pmerge->next=MergeList(phead2->next,phead1);
	}
	return pmerge;
}
